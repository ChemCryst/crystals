#YThe disk file#
# 
#PDuring a given run of CRYSTALS, the program MUST be linked to a 
 direct access file (DISK) holding the 
 data-base for the current structure. This file provides the mechanism
 for data transfer between different stages of the task, one stage of
 which may well be the input of the data itself. On sites where users
 are allocated sufficient file store to preserve their DISK file between
 jobs, the DISK also  provides a mechanism for communicating between
 jobs.
 In fact, if the DISK is preserved, CRYSTALS makes no distinction between
 successive tasks run in the same job and the same tasks
 run in successive jobs.
 Instructions exist in CRYSTALS for 'punching' out files containing reflections
 in various formats, including a compressed format, and the structure 
 coordinates.
 In most systems, the 'punched' files will remain in the filestore as character
 (ASCII) files  in a format suitable for direct re-input to a 
 subsequent job. If therefore, the user keeps a file of his initial data, such
 as cell parameters and scattering factors, and terminates each job by 
 outputting his current parameters as a 'punched' file, he is in a
 position to create a scratch DISK file for the 
 duration of a job, and then delete it at the end. Even if the user is able to
 preserve his DISK between jobs, it is prudent to punch out the parameters
 from time to time and keep these in a safe place, together with the initial
 data and the compressed reflections.
#YThe output files#
#PCRYSTALS plain-language output to a number of devices. Depending on the
 installation and mode of use, one or more of these devices may be a VDU.
 In the list below, the default file extension is given in parenthesis.
#IPRINTER  (.LIS)#
#PThis is the main output stream for the system, and contains detailed
 accounts of the calculation performed.
#IMONITOR  (.MON)#
#PThis is an abbreviated output, suitable for directing to the VDU in online
 or interactive modes. For batch mode jobs, it provides a summary of the
 computation performad.
#IPUNCH    (.PCH)#
#PUse for ouputting LISTs in a format suitable for later re-input to CRYSTALS.
 These files can be used for archiving or communication with other systems.
 (This is a FORTRAN card image file, so column 1 may not be displayed on
 some operating systems - it is there though)
#ILOG      (.LOG)#
#PA verbatim copy of the input presented to CRYSTALS. It can be used as 
 input for a subsequent job, and is thus a mechanism for rescuing partially
 correct user input.
#IERRORS   (.ERR)#
#PThis only contains operating system error information.
#
#PThe \USE instruction permits the user to feed in input from several
 different files. The \RELEASE instruction permits the user to disconnect
 the current PRINTER,PUNCH or MONITOR files from CRYSTALS (new ones are
 automatically connected). The \TYPE instruction permits the user to
 examine any file available to him, including a previously RELEASEd file,
 so that he may examine the output from some earlier part of a task without
 exiting from CRYSTALS. A long batch job can RELEASE its MONITOR file
 after, say, each round of refinement so that the user can see how the job
 is progressing. 
#YThe work files
# 
#PCRYSTALS uses a number of work files in the course of most calculations. Of
 particular interest are the sequential files. Their use in initial reflection processing is explained in
 the Manual. The system manager will provide a
 suitable JCL procedure 
 or program environment to assign these files to scratch files. The user
 should however be aware of the existence of these files on systems where
 file store quotas operate. Similar watch should be kept on output files if
 these are attributed to the user while waiting to be listed.
#PIn general, however, on a well regulated system the user should normally
 only be concerned with his primary source of reflection data, his initial
 crystallographic data, his DISK file and those files he creates
 for controlling individual jobs.









 \DISK     \PURGE
#
#PWhen the DISK is created,  special code is run to allocate space in the
 file to hold two indices, the DISK index and the CURRENT index.
 An entry is put into the DISK index for each LIST subsequently added to the
 DISK. In general, when a new LIST is input or generated by calculation
 or modification, this new list is 
 put after the last  existing list on the DISK, and its address entered
 into the DISK index. This index will now contain two or more entries for
 lists of the given type, and so that subsequent calculations will know
 which one to use, the address of the most recent is inserted into the CURRENT
 index. Thus the CURRENT index is of fixed length, with one slot for each 
 possible list type, and the DISK index is of variable length with a slot
 for each list present on the DISK. The DISK index itself consists of fixed
 length blocks. In the event that a block becomes full, a new block is chained
 to the old one. This new block will be after the last list which was written.
 The indexing of the DISK, and hence the addressing of the lists, may become
 undefined if the last DISK index block extends beyond the physical end of the 
 file. Neither the DISK nor the CURRENT index is updated until a list is 
 safely written to the DISK, so that in the event of a system failure or
 a crash of the program, no evidence remains of the incomplete list, i.e. 
 the integrity of the DISK is preserved. Exceptions to this are during
 access to the reflection list (LIST 6) and the normal matrix (LIST 11).
 Because these lists are so large, the system will either try to update or
 overwrite them. If a job fails during an update, the list cannot be accessed
 again until a job has been run to complete the update. For example, if
 a job fails during a round of least squares, there may be some Fc values
 present for the current atomic parameters, and some left from a previous
 calculation. The user will not be able to access LIST 6 for, say, a FOURIER
 synthesis until he has recomputed structure factors for all the reflections.
#PBecause new lists are usually added to the end of the DISK, the user has
 on his DISK a short term archive and record of the calculations he has done.
 In order to return to some previous state of the calculation, he merely has
 to enter the address of the list he wishes to use into the CURRENT index.
 To simplify this, each list is given a SERIAL number when it is written to the
 DISK. The serial number for LIST 5 (parameters) is usually
 displayed whenever the list is written to the
 DISK, and the user can RESET a LIST to a previous SERIAL 
 if it is prefered to the current list. Other lists can be monitored by
 the instructions \SET WATCH and \SET LIST.
 Eventually there may be so many versions of lists on the DISK
 that it risks becomming full. The user can PURGE his DISK of old lists, only
 the current or spacially marked
 ones remaining. If there are some particularly important early
 versions, the user can RETAIN them during the purge. A purge rewrites
 the required files at the beginning of the DISK, releasing space for new ones.
 It does not physically shorten the file. During a purge the DISK is in a very
 delicate state, possibly with some of the vital information only existing
 in the computer memory. A machine or job failure during a purge could well
 produce a DISK file that is unusable. The system may during certain types
 of machine or calculation failure mark lists as being in error, or alter
 their write/overwrite ststus. Such lists cannot normally be accessed for
 calculations, but if the user is convinced he understands why the flags were
 set, he can if he wishes reset them with MARK or USAGE.  Thus the status
 of LIST 6 may reasonably be reset if a failure occurs during the calculation
 of structure factors, since the Fo values will still be valid, and new Fc
 values can be recomputed. It would be quite unreasonable to reset the status
 of a LIST 6 marked as in error during data reduction. The EXTEND directive
 in \DISK allows the user to control the growth of the disk file.
# 











#IThe environment#
# 
#PIn addition to being familiar  with the organisation of CRYSTALS, the user
 will profit from being familiar with his operating environment. In particular,
 a fluency with the system editor will simplify many tasks. Editors with
 means of repeating blocks of instructions may prove particularly useful
 for processing large files, such as reflection lists, and should be mastered.
 The facilities in CRYSTALS for modifying atomic parameters are very powerfull,
 but the user should always be alert for ways of achieving particular results
 by using system editors if that would be more efficient.  It is important
 to see CRYSTALS as only part of the whole system available to the user.
 On systems offering hierarchic filenames, much of the management and control
 of files for different users and structures can be automatically achieved
 by intelligent use of system services. It is the system manager's task to
 provide the JCL procedures needed to profit from the system services,
 and the users task to understand them.
#











#YINITIALISATION file#
#POn program startup, CRYSTALS tries to obey an initialisation file,
  CRYSINIT.DAT, if it exists. This file may contain any valid CRYSTALS
 commands. Typically it contains 'system' commands like \SET <parameters>.
 It may also contain instructions to perform disk house keeping, or pass
 control to other files. In particular, the command \USE 
 CRDIR:CRYSINIT.DAT will pass control to a CRYSINIT file in the current 
 subdirectory, so that different subdirectories can have different
 initialisation files. The commands \USE CONTROL passes control to the 
 terminal or batch control file without obeying futher CRYSINIT commands,
 and can be used to terminate the SCRIPT mode of working. A command like
 \USE CRDIR:INITIAL.DAT causes the file INITIAL to be processed, and so
 provides a mechanism for loading the disk file on systems where it cannot
 be preserved between jobs.




